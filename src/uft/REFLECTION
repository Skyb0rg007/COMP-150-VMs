1. Global and local names. You can create a term in which a single name appears as both a global variable and a local variable.

    (let ([x x]) x)

2. K-normal form. You can write simple K-normal form by hand.

    let tmp = 1 in +(n, tmp)

3. K-normal form embedding. You can, by hand, embed simple K-normal form into Scheme.

    (let ([tmp 1]) (+ n tmp))

4. Names in K-normal form. You can say which names in the source code show up as what types in K-normal form.

    'a -> formal param, local variable
    vmop -> primitive function
    literal -> none

5. Software reuse. You can say how K-normal form could be used to implement other programming languages.

    Tcl:
    KNormal form would be a poor target for implementing Tcl
    In Tcl, you can have an expression such as [set $x 12], which would compute the
    name of the variable at runtime. Therefore there is no way to distinguish local and global variable manipulation

6. Embedding, projection, and language design. You can justify the fact that K-normal form has fewer expressions but more literals than Scheme.

    In a system that is targeting the SVM but does not necessarily want to be locked into translating Scheme, why is it a good idea to have K-normal form expressions be a subset of Scheme expressions?

        Generating SVM code from a K-normal form expression is easier - less cases to handle

    In a system that is targeting the SVM but does not necessarily want to be locked into translating Scheme, why is it a good idea to have K-normal form literals be a superset of Scheme values?

        Programmers may want to generate literals that are not possible by Scheme, for example nil
        However in a different language, ex. Lua, you would want to have nil be an otherwise usable literal

7. Eta-expansion. You can eta-expand cdr by hand.

    cdr -> (lambda (a) (cdr a))

8. Eta-expansion. You can say which of the K-normal form invariants is satisfied by the body of an eta-expansion.

    Every argument has a name (the special case doesn't come up with eta-expansion)

9. UFT driver. Your uft builds and understands what kn-kn is asking for.

    I am not claiming this point

10. Error monad. You can show where in your code you have exploited the error monad.

    Basically everywhere. Take a look at Uft/Scheme/Disambiguate.hs
    MonadError in Haskell ~~ error monad in SML

11. Testing. You can explain the results of your tests.

    The pipeline is not setup

12. Notation. You can use Oxford brackets to write translation equations.

    ùíú ‚ü¶goto label‚üß(k, œÅ{ label ‚Üí n }) = goto $(n - k - 1)
