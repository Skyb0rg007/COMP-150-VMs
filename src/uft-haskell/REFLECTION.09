1. Craft. You can add a new pass to the UFT driver.

    The program adds the knormalizeExp pass

2. Continuations and register allocation. You can define a continuation that reserves an allocated register, preventing its reuse.

    src/Uft/KNormal/FromUnamb.hs - line 161
    The use of function (-:-) ensures using the regsets in the future does not clobber the allocated register

3. Continuations and register reuse. You can define a continuation that reuses an allocated register.

    src/Uft/KNormal/FromUnamb.hs - line 156
    We don't use (-:-), so the register allocated to store the function
    is not used.

4. Functional programming. You can use higher-order functions to avoid near-duplicate code.

    src/Uft/KNormal/FromUnamb.hs - lines 152, 157, 160
    All use nbRegsWith

5. Calling conventions. You can implement a procedure calling convention.

    I'm not claiming this point

6. Syntactic-form testing. Your K‑normalizer is comprehensively tested.

    I'm not claiming this point

7. Integration testing. Your K‑normalizer passes an integration test.

    I'm not claiming this point

8. Functional languages and mutation. You can explain how the possibility of mutation affects choices available to the UFT.

    I use the bindAnyReg policy.

    When let-binding, we don't want to allocate more registers if we don't
    need to. So given the code:

    (let ((x y))
     (print x))

    If variable y is allocated in register 2, then we want to generate the code:

    print 2

    If we use the bindSmallest policy, we generate:

    copyreg 3 2
    print 3

    Because the bindSmallest policy allocates an additional register




